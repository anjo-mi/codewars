<h2><a href=https://www.codewars.com/kata/5737f14449fc581de9001845/train/javascript target="_blank">Inner Calls In Recursion I</a></h2><h3>6 kyu</h3><p>For a certain simulation, a group of students have to produce numbers close to <code>2</code> in a certain order. Their instructor guide them explaining an algorithm useful for that task.</p><p>An array of integers, arr, is received.</p><p>arr = [n1, n2, ....,nk]</p><p>The array should be transformed, doing the following steps:</p><ul><li>each value of the array, <code>ni</code>, will be substituted by the value <code>(ni + μ) / μ</code></li></ul><p><code>μ = (Σ ni) / k  (mean of the array)</code></p><p>After doing this process recursively, it will be seen that the final array will trend to this final one: <code>[2.0, 2.0, .....2.0]</code></p><p>Let's start with this one: <code>[12, 7, 23]</code></p><pre><code>array                                               μ                             transformed array                        number of calls[12, 7, 23]                                        14.0             [1.8571428571428572, 1.5, 2.642857142857143]                1[1.8571428571428572, 1.5, 2.642857142857143]        2.0             [1.9285714285714286, 1.75, 2.321428571428571]               2[1.9285714285714286, 1.75, 2.321428571428571]       2.0             [1.9642857142857144, 1.875, 2.1607142857142856]             3.............................................       ....             ............................................               ................................................       ....             ............................................               ...[2.0, 2.0, 2.0]                                     2.0             [2.0, 2.0, 2.0]                                            54</code></pre><p>After certain number of recursive steps, the difference between <code>2</code> and the obtained values is so small that cannot be detected by the programming language system.</p><p>In order to estimate the amount of generated values, they need to determine the number of recursive calls for this process.</p><p>Do you want to help them?</p><p>They need the function <code>simul_close_to2()</code> that receives a certain array, and a minimum absolute error, <code>abs_error</code>. The function will output the inner calls.</p><p>The recursion should stop when <code>|arr[i] - arr[i + 1]| ≤ abs_error</code> for all <code>i</code> of the array. For that purpose we need a helper function <code>are_contigElemen_closeEnough()</code> that receives an array and the abs_error and outputs True when this condition is fulfilled and False when not.</p><p>Let's see the above case for different absolute errors:</p><pre><code class="language-python"><span class="cm-variable">simul_close_to2</span>([<span class="cm-number">12</span>, <span class="cm-number">7</span>, <span class="cm-number">23</span>], <span class="cm-builtin">pow</span>(<span class="cm-number">10</span>, <span class="cm-operator">-</span><span class="cm-number">5</span>)) <span class="cm-operator">==</span> <span class="cm-number">18</span> <span class="cm-comment"># final array [1.9999989100864957, 1.9999961853027344, 2.00000490461077]</span><span class="cm-variable">simul_close_to2</span>([<span class="cm-number">12</span>, <span class="cm-number">7</span>, <span class="cm-number">23</span>], <span class="cm-builtin">pow</span>(<span class="cm-number">10</span>, <span class="cm-operator">-</span><span class="cm-number">8</span>)) <span class="cm-operator">==</span> <span class="cm-number">28</span> <span class="cm-comment"># final array [1.9999999989356314, 1.9999999962747097, 2.000000004789659]</span><span class="cm-variable">simul_close_to2</span>([<span class="cm-number">12</span>, <span class="cm-number">7</span>, <span class="cm-number">23</span>], <span class="cm-builtin">pow</span>(<span class="cm-number">10</span>, <span class="cm-operator">-</span><span class="cm-number">12</span>)) <span class="cm-operator">==</span> <span class="cm-number">42</span> <span class="cm-comment"># final array [1.9999999999999352, 1.9999999999997726, 2.000000000000292]</span></code></pre><p>The tests for the function will have the following features:</p><pre><code>N &lt; 250 (N, number of tests)3 ≤ L ≤ 5000 (L, length of the array)1 ≤ ni ≤ 10000000 (arr = [n1, n2,..., ni, ..., nk])10^(-17) ≤ abs_error ≤ 0.001</code></pre><p>Enjoy it!</p>